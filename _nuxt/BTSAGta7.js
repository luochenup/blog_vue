import{O as bt,N as ot,e as it,_ as _t,b as Ft,h as N,P as rt,Q as ct,l as Ct,R as Mt,S as Lt,c as Tt}from"./raXDgERY.js";import{C as B,c as b,V as Ot,W as gt,L as v,R as D,U as S,a4 as W,_ as O,X as T,aa as $,Z as pt,ag as V,a9 as et,Y as F,j as G,F as M,w as U,n as Vt,ah as Et,ak as $t,l as at,T as ut,ao as K,av as lt,d as At,aw as Dt,af as Pt,$ as jt,a0 as Rt,a2 as Nt}from"./Dkj_qHQx.js";import{u as Bt,b as Wt}from"./CS7__6sN.js";function Ut(o="",t={size:92}){if(!o)return"";t.preset==="icon"&&(t={...t,size:32,mask:"circle"});const e=new URLSearchParams;return e.set("url",`github.com/${o}.png`),t.size&&e.set("url",`${e.get("url")}?size=${t.size}`),t.mask&&e.set("mask",t.mask),`https://wsrv.nl/?${e.toString()}`}const Kt={class:"badge-text"},Jt=B({__name:"Badge",props:{img:{},text:{},link:{},round:{type:Boolean},square:{type:Boolean}},setup(o){const t=o,e=b(()=>{if(t.img)return t.img;const i=bt(t.link);return i?Ut(i):t.link&&ot(t.link)?`https://unavatar.webp.se/${it(t.link)}?w`:""}),s=b(()=>e.value?!t.square:t.round),n=b(()=>t.link?ot(t.link)?it(t.link):decodeURIComponent(t.link):"");return(i,r)=>{const c=Ft,a=_t,u=Ot("tip");return gt((S(),D(a,{class:W(["badge",{round:v(s)}]),to:i.link},{default:O(()=>[v(e)?(S(),D(c,{key:0,class:"badge-icon",src:v(e),alt:v(e)},null,8,["src","alt"])):T("",!0),$("span",Kt,[pt(i.$slots,"default",{},()=>[V(et(i.text),1)],!0)])]),_:3},8,["class","to"])),[[u,v(n)]])}}}),qt=Object.assign(N(Jt,[["__scopeId","data-v-440f286e"]]),{__name:"Badge"}),Qt={class:"title text-creative"},Ht=["innerHTML"],Zt=["innerHTML"],Gt=B({__name:"SearchItem",props:{title:{},content:{},titles:{},level:{},originalPath:{},id:{},terms:{},queryTerms:{},score:{},match:{}},setup(o){const t=o,e=b(()=>[...t.titles??[],t.title].join(" > ")),s=b(()=>t.queryTerms?.[0]??""),n=b(()=>rt(e.value,s.value)),i=b(()=>rt(t.content??"",s.value)),r=b(()=>t.originalPath||t.id);return(c,a)=>{const u=qt,d=_t;return S(),D(d,{to:v(r),class:"search-item"},{default:O(()=>[$("div",Qt,[F(u,{round:"",class:W({primary:c.level===1})},{default:O(()=>[V(et(c.level===1?"文章":`H${c.level}`),1)]),_:1},8,["class"]),$("span",{innerHTML:v(n)},null,8,Ht)]),$("p",{class:"content",innerHTML:v(i)},null,8,Zt)]),_:1},8,["to"])}}}),Yt=Object.assign(N(Gt,[["__scopeId","data-v-11a294fa"]]),{__name:"ZSearchItem"}),Xt=B({__name:"Key",props:{code:{},text:{},ctrl:{type:Boolean},shift:{type:Boolean},alt:{type:Boolean},meta:{type:Boolean}},emits:["press"],setup(o,{emit:t}){const e=o,s=t,n=G(!1);function i(r){return(!e.ctrl||e.ctrl===r.ctrlKey)&&(!e.shift||e.shift===r.shiftKey)&&(!e.alt||e.alt===r.altKey)&&(!e.meta||e.meta===r.metaKey)}return ct("keydown",r=>{r.key?.toLowerCase()===e.code?.toLowerCase()&&i(r)&&(s("press"),n.value=!0)}),ct("keyup",r=>{r.key?.toLowerCase()===e.code?.toLowerCase()&&i(r)&&(n.value=!1)}),(r,c)=>(S(),M("kbd",{class:W({active:v(n)}),onClick:c[0]||(c[0]=a=>s("press"))},[pt(r.$slots,"default",{},()=>[V(et(r.text||r.code),1)],!0)],2))}}),te=Object.assign(N(Xt,[["__scopeId","data-v-b5843e40"]]),{__name:"Key"}),ee="ENTRIES",vt="KEYS",wt="VALUES",k="";class J{constructor(t,e){const s=t._tree,n=Array.from(s.keys());this.set=t,this._type=e,this._path=n.length>0?[{node:s,keys:n}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:e}=E(this._path);if(E(e)===k)return{done:!1,value:this.result()};const s=t.get(E(e));return this._path.push({node:s,keys:Array.from(s.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==k).join("")}value(){return E(this._path).node.get(k)}result(){switch(this._type){case wt:return this.value();case vt:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=o=>o[o.length-1],se=(o,t,e)=>{const s=new Map;if(t===void 0)return s;const n=t.length+1,i=n+e,r=new Uint8Array(i*n).fill(e+1);for(let c=0;c<n;++c)r[c]=c;for(let c=1;c<i;++c)r[c*n]=c;return yt(o,t,e,s,r,1,n,""),s},yt=(o,t,e,s,n,i,r,c)=>{const a=i*r;t:for(const u of o.keys())if(u===k){const d=n[a-1];d<=e&&s.set(c,[o.get(u),d])}else{let d=i;for(let m=0;m<u.length;++m,++d){const h=u[m],g=r*d,_=g-r;let f=n[g];const p=Math.max(0,d-e-1),w=Math.min(r-1,d+e);for(let l=p;l<w;++l){const z=h!==t[l],x=n[_+l]+ +z,I=n[_+l+1]+1,y=n[g+l]+1,C=n[g+l+1]=Math.min(x,I,y);C<f&&(f=C)}if(f>e)continue t}yt(o.get(u),t,e,s,n,d,r,c+u)}};class L{constructor(t=new Map,e=""){this._size=void 0,this._tree=t,this._prefix=e}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[e,s]=R(this._tree,t.slice(this._prefix.length));if(e===void 0){const[n,i]=st(s);for(const r of n.keys())if(r!==k&&r.startsWith(i)){const c=new Map;return c.set(r.slice(i.length),n.get(r)),new L(c,t)}}return new L(e,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ne(this._tree,t)}entries(){return new J(this,ee)}forEach(t){for(const[e,s]of this)t(e,s,this)}fuzzyGet(t,e){return se(this._tree,t,e)}get(t){const e=Y(this._tree,t);return e!==void 0?e.get(k):void 0}has(t){const e=Y(this._tree,t);return e!==void 0&&e.has(k)}keys(){return new J(this,vt)}set(t,e){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,q(this._tree,t).set(k,e),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,e){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const s=q(this._tree,t);return s.set(k,e(s.get(k))),this}fetch(t,e){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const s=q(this._tree,t);let n=s.get(k);return n===void 0&&s.set(k,n=e()),n}values(){return new J(this,wt)}[Symbol.iterator](){return this.entries()}static from(t){const e=new L;for(const[s,n]of t)e.set(s,n);return e}static fromObject(t){return L.from(Object.entries(t))}}const R=(o,t,e=[])=>{if(t.length===0||o==null)return[o,e];for(const s of o.keys())if(s!==k&&t.startsWith(s))return e.push([o,s]),R(o.get(s),t.slice(s.length),e);return e.push([o,t]),R(void 0,"",e)},Y=(o,t)=>{if(t.length===0||o==null)return o;for(const e of o.keys())if(e!==k&&t.startsWith(e))return Y(o.get(e),t.slice(e.length))},q=(o,t)=>{const e=t.length;t:for(let s=0;o&&s<e;){for(const i of o.keys())if(i!==k&&t[s]===i[0]){const r=Math.min(e-s,i.length);let c=1;for(;c<r&&t[s+c]===i[c];)++c;const a=o.get(i);if(c===i.length)o=a;else{const u=new Map;u.set(i.slice(c),a),o.set(t.slice(s,s+c),u),o.delete(i),o=u}s+=c;continue t}const n=new Map;return o.set(t.slice(s),n),n}return o},ne=(o,t)=>{const[e,s]=R(o,t);if(e!==void 0){if(e.delete(k),e.size===0)kt(s);else if(e.size===1){const[n,i]=e.entries().next().value;St(s,n,i)}}},kt=o=>{if(o.length===0)return;const[t,e]=st(o);if(t.delete(e),t.size===0)kt(o.slice(0,-1));else if(t.size===1){const[s,n]=t.entries().next().value;s!==k&&St(o.slice(0,-1),s,n)}},St=(o,t,e)=>{if(o.length===0)return;const[s,n]=st(o);s.set(n+t,e),s.delete(n)},st=o=>o[o.length-1],nt="or",It="and",oe="and_not";class A{constructor(t){if(t?.fields==null)throw new Error('MiniSearch: option "fields" must be provided');const e=t.autoVacuum==null||t.autoVacuum===!0?Z:t.autoVacuum;this._options={...H,...t,autoVacuum:e,searchOptions:{...dt,...t.searchOptions||{}},autoSuggestOptions:{...ue,...t.autoSuggestOptions||{}}},this._index=new L,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=tt,this.addFields(this._options.fields)}add(t){const{extractField:e,tokenize:s,processTerm:n,fields:i,idField:r}=this._options,c=e(t,r);if(c==null)throw new Error(`MiniSearch: document does not have ID field "${r}"`);if(this._idToShortId.has(c))throw new Error(`MiniSearch: duplicate ID ${c}`);const a=this.addDocumentId(c);this.saveStoredFields(a,t);for(const u of i){const d=e(t,u);if(d==null)continue;const m=s(d.toString(),u),h=this._fieldIds[u],g=new Set(m).size;this.addFieldLength(a,h,this._documentCount-1,g);for(const _ of m){const f=n(_,u);if(Array.isArray(f))for(const p of f)this.addTerm(h,a,p);else f&&this.addTerm(h,a,f)}}}addAll(t){for(const e of t)this.add(e)}addAllAsync(t,e={}){const{chunkSize:s=10}=e,n={chunk:[],promise:Promise.resolve()},{chunk:i,promise:r}=t.reduce(({chunk:c,promise:a},u,d)=>(c.push(u),(d+1)%s===0?{chunk:[],promise:a.then(()=>new Promise(m=>setTimeout(m,0))).then(()=>this.addAll(c))}:{chunk:c,promise:a}),n);return r.then(()=>this.addAll(i))}remove(t){const{tokenize:e,processTerm:s,extractField:n,fields:i,idField:r}=this._options,c=n(t,r);if(c==null)throw new Error(`MiniSearch: document does not have ID field "${r}"`);const a=this._idToShortId.get(c);if(a==null)throw new Error(`MiniSearch: cannot remove document with ID ${c}: it is not in the index`);for(const u of i){const d=n(t,u);if(d==null)continue;const m=e(d.toString(),u),h=this._fieldIds[u],g=new Set(m).size;this.removeFieldLength(a,h,this._documentCount,g);for(const _ of m){const f=s(_,u);if(Array.isArray(f))for(const p of f)this.removeTerm(h,a,p);else f&&this.removeTerm(h,a,f)}}this._storedFields.delete(a),this._documentIds.delete(a),this._idToShortId.delete(c),this._fieldLength.delete(a),this._documentCount-=1}removeAll(t){if(t)for(const e of t)this.remove(e);else{if(arguments.length>0)throw new Error("Expected documents to be present. Omit the argument to remove all documents.");this._index=new L,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldLength=new Map,this._avgFieldLength=[],this._storedFields=new Map,this._nextId=0}}discard(t){const e=this._idToShortId.get(t);if(e==null)throw new Error(`MiniSearch: cannot discard document with ID ${t}: it is not in the index`);this._idToShortId.delete(t),this._documentIds.delete(e),this._storedFields.delete(e),(this._fieldLength.get(e)||[]).forEach((s,n)=>{this.removeFieldLength(e,n,this._documentCount,s)}),this._fieldLength.delete(e),this._documentCount-=1,this._dirtCount+=1,this.maybeAutoVacuum()}maybeAutoVacuum(){if(this._options.autoVacuum===!1)return;const{minDirtFactor:t,minDirtCount:e,batchSize:s,batchWait:n}=this._options.autoVacuum;this.conditionalVacuum({batchSize:s,batchWait:n},{minDirtCount:e,minDirtFactor:t})}discardAll(t){const e=this._options.autoVacuum;try{this._options.autoVacuum=!1;for(const s of t)this.discard(s)}finally{this._options.autoVacuum=e}this.maybeAutoVacuum()}replace(t){const{idField:e,extractField:s}=this._options,n=s(t,e);this.discard(n),this.add(t)}vacuum(t={}){return this.conditionalVacuum(t)}conditionalVacuum(t,e){return this._currentVacuum?(this._enqueuedVacuumConditions=this._enqueuedVacuumConditions&&e,this._enqueuedVacuum!=null?this._enqueuedVacuum:(this._enqueuedVacuum=this._currentVacuum.then(()=>{const s=this._enqueuedVacuumConditions;return this._enqueuedVacuumConditions=tt,this.performVacuuming(t,s)}),this._enqueuedVacuum)):this.vacuumConditionsMet(e)===!1?Promise.resolve():(this._currentVacuum=this.performVacuuming(t),this._currentVacuum)}async performVacuuming(t,e){const s=this._dirtCount;if(this.vacuumConditionsMet(e)){const n=t.batchSize||X.batchSize,i=t.batchWait||X.batchWait;let r=1;for(const[c,a]of this._index){for(const[u,d]of a)for(const[m]of d)this._documentIds.has(m)||(d.size<=1?a.delete(u):d.delete(m));this._index.get(c).size===0&&this._index.delete(c),r%n===0&&await new Promise(u=>setTimeout(u,i)),r+=1}this._dirtCount-=s}await null,this._currentVacuum=this._enqueuedVacuum,this._enqueuedVacuum=null}vacuumConditionsMet(t){if(t==null)return!0;let{minDirtCount:e,minDirtFactor:s}=t;return e=e||Z.minDirtCount,s=s||Z.minDirtFactor,this.dirtCount>=e&&this.dirtFactor>=s}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}has(t){return this._idToShortId.has(t)}getStoredFields(t){const e=this._idToShortId.get(t);if(e!=null)return this._storedFields.get(e)}search(t,e={}){const{searchOptions:s}=this._options,n={...s,...e},i=this.executeQuery(t,e),r=[];for(const[c,{score:a,terms:u,match:d}]of i){const m=u.length||1,h={id:this._documentIds.get(c),score:a*m,terms:Object.keys(d),queryTerms:u,match:d};Object.assign(h,this._storedFields.get(c)),(n.filter==null||n.filter(h))&&r.push(h)}return t===A.wildcard&&n.boostDocument==null||r.sort(ft),r}autoSuggest(t,e={}){e={...this._options.autoSuggestOptions,...e};const s=new Map;for(const{score:i,terms:r}of this.search(t,e)){const c=r.join(" "),a=s.get(c);a!=null?(a.score+=i,a.count+=1):s.set(c,{score:i,terms:r,count:1})}const n=[];for(const[i,{score:r,terms:c,count:a}]of s)n.push({suggestion:i,terms:c,score:r/a});return n.sort(ft),n}get documentCount(){return this._documentCount}get termCount(){return this._index.size}static loadJSON(t,e){if(e==null)throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJS(JSON.parse(t),e)}static async loadJSONAsync(t,e){if(e==null)throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJSAsync(JSON.parse(t),e)}static getDefault(t){if(H.hasOwnProperty(t))return Q(H,t);throw new Error(`MiniSearch: unknown option "${t}"`)}static loadJS(t,e){const{index:s,documentIds:n,fieldLength:i,storedFields:r,serializationVersion:c}=t,a=this.instantiateMiniSearch(t,e);a._documentIds=P(n),a._fieldLength=P(i),a._storedFields=P(r);for(const[u,d]of a._documentIds)a._idToShortId.set(d,u);for(const[u,d]of s){const m=new Map;for(const h of Object.keys(d)){let g=d[h];c===1&&(g=g.ds),m.set(parseInt(h,10),P(g))}a._index.set(u,m)}return a}static async loadJSAsync(t,e){const{index:s,documentIds:n,fieldLength:i,storedFields:r,serializationVersion:c}=t,a=this.instantiateMiniSearch(t,e);a._documentIds=await j(n),a._fieldLength=await j(i),a._storedFields=await j(r);for(const[d,m]of a._documentIds)a._idToShortId.set(m,d);let u=0;for(const[d,m]of s){const h=new Map;for(const g of Object.keys(m)){let _=m[g];c===1&&(_=_.ds),h.set(parseInt(g,10),await j(_))}++u%1e3===0&&await zt(0),a._index.set(d,h)}return a}static instantiateMiniSearch(t,e){const{documentCount:s,nextId:n,fieldIds:i,averageFieldLength:r,dirtCount:c,serializationVersion:a}=t;if(a!==1&&a!==2)throw new Error("MiniSearch: cannot deserialize an index created with an incompatible version");const u=new A(e);return u._documentCount=s,u._nextId=n,u._idToShortId=new Map,u._fieldIds=i,u._avgFieldLength=r,u._dirtCount=c||0,u._index=new L,u}executeQuery(t,e={}){if(t===A.wildcard)return this.executeWildcardQuery(e);if(typeof t!="string"){const h={...e,...t,queries:void 0},g=t.queries.map(_=>this.executeQuery(_,h));return this.combineResults(g,h.combineWith)}const{tokenize:s,processTerm:n,searchOptions:i}=this._options,r={tokenize:s,processTerm:n,...i,...e},{tokenize:c,processTerm:a}=r,m=c(t).flatMap(h=>a(h)).filter(h=>!!h).map(ae(r)).map(h=>this.executeQuerySpec(h,r));return this.combineResults(m,r.combineWith)}executeQuerySpec(t,e){const s={...this._options.searchOptions,...e},n=(s.fields||this._options.fields).reduce((f,p)=>({...f,[p]:Q(s.boost,p)||1}),{}),{boostDocument:i,weights:r,maxFuzzy:c,bm25:a}=s,{fuzzy:u,prefix:d}={...dt.weights,...r},m=this._index.get(t.term),h=this.termResults(t.term,t.term,1,t.termBoost,m,n,i,a);let g,_;if(t.prefix&&(g=this._index.atPrefix(t.term)),t.fuzzy){const f=t.fuzzy===!0?.2:t.fuzzy,p=f<1?Math.min(c,Math.round(t.term.length*f)):f;p&&(_=this._index.fuzzyGet(t.term,p))}if(g)for(const[f,p]of g){const w=f.length-t.term.length;if(!w)continue;_?.delete(f);const l=d*f.length/(f.length+.3*w);this.termResults(t.term,f,l,t.termBoost,p,n,i,a,h)}if(_)for(const f of _.keys()){const[p,w]=_.get(f);if(!w)continue;const l=u*f.length/(f.length+w);this.termResults(t.term,f,l,t.termBoost,p,n,i,a,h)}return h}executeWildcardQuery(t){const e=new Map,s={...this._options.searchOptions,...t};for(const[n,i]of this._documentIds){const r=s.boostDocument?s.boostDocument(i,"",this._storedFields.get(n)):1;e.set(n,{score:r,terms:[],match:{}})}return e}combineResults(t,e=nt){if(t.length===0)return new Map;const s=e.toLowerCase(),n=ie[s];if(!n)throw new Error(`Invalid combination operator: ${e}`);return t.reduce(n)||new Map}toJSON(){const t=[];for(const[e,s]of this._index){const n={};for(const[i,r]of s)n[i]=Object.fromEntries(r);t.push([e,n])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}termResults(t,e,s,n,i,r,c,a,u=new Map){if(i==null)return u;for(const d of Object.keys(r)){const m=r[d],h=this._fieldIds[d],g=i.get(h);if(g==null)continue;let _=g.size;const f=this._avgFieldLength[h];for(const p of g.keys()){if(!this._documentIds.has(p)){this.removeTerm(h,p,e),_-=1;continue}const w=c?c(this._documentIds.get(p),e,this._storedFields.get(p)):1;if(!w)continue;const l=g.get(p),z=this._fieldLength.get(p)[h],x=ce(l,_,this._documentCount,z,f,a),I=s*n*m*w*x,y=u.get(p);if(y){y.score+=I,le(y.terms,t);const C=Q(y.match,e);C?C.push(d):y.match[e]=[d]}else u.set(p,{score:I,terms:[t],match:{[e]:[d]}})}}return u}addTerm(t,e,s){const n=this._index.fetch(s,mt);let i=n.get(t);if(i==null)i=new Map,i.set(e,1),n.set(t,i);else{const r=i.get(e);i.set(e,(r||0)+1)}}removeTerm(t,e,s){if(!this._index.has(s)){this.warnDocumentChanged(e,t,s);return}const n=this._index.fetch(s,mt),i=n.get(t);i==null||i.get(e)==null?this.warnDocumentChanged(e,t,s):i.get(e)<=1?i.size<=1?n.delete(t):i.delete(e):i.set(e,i.get(e)-1),this._index.get(s).size===0&&this._index.delete(s)}warnDocumentChanged(t,e,s){for(const n of Object.keys(this._fieldIds))if(this._fieldIds[n]===e){this._options.logger("warn",`MiniSearch: document with ID ${this._documentIds.get(t)} has changed before removal: term "${s}" was not present in field "${n}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}}addDocumentId(t){const e=this._nextId;return this._idToShortId.set(t,e),this._documentIds.set(e,t),this._documentCount+=1,this._nextId+=1,e}addFields(t){for(let e=0;e<t.length;e++)this._fieldIds[t[e]]=e}addFieldLength(t,e,s,n){let i=this._fieldLength.get(t);i==null&&this._fieldLength.set(t,i=[]),i[e]=n;const c=(this._avgFieldLength[e]||0)*s+n;this._avgFieldLength[e]=c/(s+1)}removeFieldLength(t,e,s,n){if(s===1){this._avgFieldLength[e]=0;return}const i=this._avgFieldLength[e]*s-n;this._avgFieldLength[e]=i/(s-1)}saveStoredFields(t,e){const{storeFields:s,extractField:n}=this._options;if(s==null||s.length===0)return;let i=this._storedFields.get(t);i==null&&this._storedFields.set(t,i={});for(const r of s){const c=n(e,r);c!==void 0&&(i[r]=c)}}}A.wildcard=Symbol("*");const Q=(o,t)=>Object.prototype.hasOwnProperty.call(o,t)?o[t]:void 0,ie={[nt]:(o,t)=>{for(const e of t.keys()){const s=o.get(e);if(s==null)o.set(e,t.get(e));else{const{score:n,terms:i,match:r}=t.get(e);s.score=s.score+n,s.match=Object.assign(s.match,r),ht(s.terms,i)}}return o},[It]:(o,t)=>{const e=new Map;for(const s of t.keys()){const n=o.get(s);if(n==null)continue;const{score:i,terms:r,match:c}=t.get(s);ht(n.terms,r),e.set(s,{score:n.score+i,terms:n.terms,match:Object.assign(n.match,c)})}return e},[oe]:(o,t)=>{for(const e of t.keys())o.delete(e);return o}},re={k:1.2,b:.7,d:.5},ce=(o,t,e,s,n,i)=>{const{k:r,b:c,d:a}=i;return Math.log(1+(e-t+.5)/(t+.5))*(a+o*(r+1)/(o+r*(1-c+c*s/n)))},ae=o=>(t,e,s)=>{const n=typeof o.fuzzy=="function"?o.fuzzy(t,e,s):o.fuzzy||!1,i=typeof o.prefix=="function"?o.prefix(t,e,s):o.prefix===!0,r=typeof o.boostTerm=="function"?o.boostTerm(t,e,s):1;return{term:t,fuzzy:n,prefix:i,termBoost:r}},H={idField:"id",extractField:(o,t)=>o[t],tokenize:o=>o.split(de),processTerm:o=>o.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(o,t)=>{typeof console?.[o]=="function"&&console[o](t)},autoVacuum:!0},dt={combineWith:nt,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:re},ue={combineWith:It,prefix:(o,t,e)=>t===e.length-1},X={batchSize:1e3,batchWait:10},tt={minDirtFactor:.1,minDirtCount:20},Z={...X,...tt},le=(o,t)=>{o.includes(t)||o.push(t)},ht=(o,t)=>{for(const e of t)o.includes(e)||o.push(e)},ft=({score:o},{score:t})=>t-o,mt=()=>new Map,P=o=>{const t=new Map;for(const e of Object.keys(o))t.set(parseInt(e,10),o[e]);return t},j=async o=>{const t=new Map;let e=0;for(const s of Object.keys(o))t.set(parseInt(s,10),o[s]),++e%1e3===0&&await zt(0);return t},zt=o=>new Promise(t=>setTimeout(t,o)),de=/[\n\r\p{Z}\p{P}]+/u,he={class:"z-search"},fe={key:0,id:"z-search"},me={key:0,class:"no-result"},_e={key:1,ref:"list-result",class:"scrollcheck-y search-result"},ge=B({__name:"Search",props:{isOpening:{type:Boolean}},async setup(o){let t,e;const s=o,n=Ct(),i=Mt(),r=G();U(()=>s.isOpening,async w=>{await Vt(),w&&r.value?.select()});const{word:c}=Lt(i),a=G(0),u=Et("list-result"),{data:d,status:m}=([t,e]=$t(()=>Bt("search",()=>Wt("content",{ignoredTags:["code"]}))),t=await t,e(),t),h=new A({fields:["title","content"],storeFields:["title","titles","content","level"],searchOptions:{prefix:!0,fuzzy:.2}}),g=b(()=>{if(!d.value)return[];const w=new Map,l=[];for(const z of d.value){let x=z.id,I=1;for(;w.has(x);)x=`${z.id}_${I}`,I++;w.set(x,!0),l.push({...z,id:x,originalPath:z.id})}return l});h.addAll(at(g.value||[]));const _=b(()=>h.search(at(c)));U(c,()=>{a.value=0}),U(a,(w,l)=>{_.value?.length&&(w<0||w>=_.value?.length)&&(a.value=l)});function f(){u.value?.children[a.value]?.scrollIntoView({behavior:"smooth",block:"nearest"})}function p(){u.value?.children[a.value]?.dispatchEvent(new Event("click"))}return(w,l)=>{const z=Tt,x=Yt,I=te;return S(),M("div",he,[F(ut,null,{default:O(()=>[w.isOpening?(S(),M("div",{key:0,id:"z-search-bgmask",onClick:l[0]||(l[0]=y=>v(n).toggle("search"))})):T("",!0)]),_:1}),F(ut,{name:"float-in"},{default:O(()=>[w.isOpening?(S(),M("div",fe,[$("form",{class:W(["input",{searching:v(m)==="pending"}]),onSubmit:l[5]||(l[5]=K(()=>{},["prevent"]))},[F(z,{name:"ph:magnifying-glass-bold"}),gt($("input",{ref_key:"searchInput",ref:r,"onUpdate:modelValue":l[1]||(l[1]=y=>At(c)?c.value=y:null),class:"search-input",placeholder:"键入开始搜索",onKeydown:[l[2]||(l[2]=lt(K(()=>{},["prevent"]),["up"])),l[3]||(l[3]=lt(K(()=>{},["prevent"]),["down"]))]},null,544),[[Dt,v(c)]]),v(c)?(S(),D(z,{key:0,class:"close",name:"ph:x-bold",onClick:l[4]||(l[4]=y=>c.value="")})):T("",!0)],34),F(Pt,{name:"expand"},{default:O(()=>[v(c)&&v(m)==="success"&&!v(_)?.length?(S(),M("div",me," 无结果 ")):T("",!0),v(c)&&v(_)?.length?(S(),M("ol",_e,[(S(!0),M(jt,null,Rt(v(_),(y,C)=>(S(),D(x,Nt({key:y.id},{ref_for:!0},y,{class:{active:v(a)===C},onClick:l[6]||(l[6]=xt=>v(n).toggle("search")),onMouseover:xt=>a.value=C}),null,16,["class","onMouseover"]))),128))],512)):T("",!0),v(c)&&v(_)?.length?(S(),M("div",{key:2,class:"tip",onClick:l[10]||(l[10]=y=>v(r)?.focus())},[F(I,{code:"arrowup",text:"↑",onPress:l[7]||(l[7]=y=>(a.value--,f()))}),F(I,{code:"arrowdown",text:"↓",onPress:l[8]||(l[8]=y=>(a.value++,f()))}),l[12]||(l[12]=V(" 切换  ",-1)),F(I,{code:"Enter",onPress:p}),l[13]||(l[13]=V(" 选择  ",-1)),F(I,{code:"escape",onPress:l[9]||(l[9]=y=>v(n).toggle("search"))},{default:O(()=>[...l[11]||(l[11]=[V(" Esc ",-1)])]),_:1}),l[14]||(l[14]=V(" 关闭 ",-1))])):T("",!0)]),_:1})])):T("",!0)]),_:1})])}}}),ye=Object.assign(N(ge,[["__scopeId","data-v-645d3a1c"]]),{__name:"PopoverSearch"});export{ye as default};
